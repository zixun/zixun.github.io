
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>子循(SubCycle)</title>
	<meta name="author" content="陈奕龙">

	
	<meta name="description" content="Mar 10th, 2017 Swift APM大轮子-GodEye 什么是GodEye 什么是GodEye？这个问题可以让GodEye自己告诉我们。 打开GodEye后，我们可以看到第一个tab页有一个Terminal的入口，这个功能是用来输入接入方自己预置的指令的， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="子循(SubCycle)" type="application/atom+xml">
	
	<link rel="canonical" href="http://zixun.github.io/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("chenyl.exe@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="http://about.me/shashankmehta">About</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

<section class="aboutme">
  <p>
    记录我的技术与生活
  </p>
</section>
</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:chenyl.exe@gmail.com" title="Email">Email</a>
		
		
		
		
		
			<a class="github" href="https://github.com/zixun" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2017-03-10T15:30:12+08:00" data-updated="true" itemprop="datePublished">Mar 10<span>th</span>, 2017</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2017/03/10/swift-apmda-lun-zi-godeye/" itemprop="url">Swift APM大轮子-GodEye</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>什么是GodEye</h1>

<p>什么是GodEye？这个问题可以让GodEye自己告诉我们。</p>

<p>打开GodEye后，我们可以看到第一个tab页有一个Terminal的入口，这个功能是用来输入接入方自己预置的指令的，当然GodEye有一个默认的指令<code>help</code>可以输出一小段GodEye的自我介绍以及接入方自己已经预置的指令列表：</p>

<p><img src="/images/custom/post/swift-apm-godeye/help.jpg" alt="hello world" /></p>

<p>由于在我们截图的demo里并没有配置预置指令，因此这里的Commands没有输出任何一个指令，当然这不是重点，重点是GodEye的自我介绍，我们可以看到这样一句话：</p>

<pre><code>Automaticly disply Log,Crash,Network,ANR,Leak,CPU,RAM,FPS,NetFlow,Folder and etc with one line of code. Just like God opened his eyes
</code></pre>

<p>翻译过来就是GodEye是一个可以通过一行代码来自动展示日志，崩溃，网络，卡顿，内存泄漏以及CPU，RAM,FPS,网络流量，文件目录等硬件信息的工具，就像上帝睁开了他的眼睛。</p>

<h2>如何打开</h2>

<p>在任何界面下三个手指上滑，或者点击GodEye的AssistiveButton即可</p>

<h2>特色</h2>

<p>功能丰富，一行代码接入，零代码入侵</p>

<p>线上包可完全不打入代码</p>

<h2>安装</h2>

<p>GodEye目前可以通过CocoaPods来安装，只需要将下面的代码加入到你的Podfile中即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">pod</span> <span class="s1">&#39;GodEye&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，在我们的<code>application:didFinishLaunchingWithOptions</code>方法中通过一行代码即可接入:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">GodEye</span><span class="o">.</span><span class="n">makeEye</span><span class="p">(</span><span class="ss">with</span><span class="p">:</span> <span class="nb">self</span><span class="o">.</span><span class="n">window!</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，一行代码接入是一种默认配置的接入，读者也可以通过传入自己的<code>Configuration</code>来精细化配置各个细节，这里就不展开说了，感兴趣的可以看一下Configuration注释就好。</p>

<h1>GodEye提供的功能</h1>

<p>上一节我们简单的介绍了下GodEye，可见GodEye提供的功能很多，这一节我们以GodEye的界面为基础，简单介绍下GodEye能提供给我们什么样的功能</p>

<h2>Console</h2>

<p>打开GodEye后我们可以看到第一个Tab页的名字是Console，是的，这个tab下都是一些输出的控制台，和一个Terminal的输入控制台：</p>

<p><img src="/images/custom/post/swift-apm-godeye/console.jpg" alt="hello world" />
由图可见，在Console模块中我们可以查看日志，崩溃，网络， 卡顿，内存泄漏，以及一个输入指令的终端。</p>

<h3>Log</h3>

<p>第一个子模块就是Log，也就是日志，点击进入后可以看到如下日志列表：</p>

<p><img src="/images/custom/post/swift-apm-godeye/log.jpg" alt="hello world" /></p>

<p>Log模块可以自动记录ASL（Apple System Log）以及Log4G的日志，并按照顺序自动展示在该列表中，关于ASL以及Log4G的详细信息可以参看第一章节&mdash;日志监控</p>

<h3>Crash</h3>

<p>第二个子模块就是Crash，也就是崩溃模块，该模块可以全自动监控App中的<code>Uncatched Exception</code>崩溃以及底层Signal崩溃。</p>

<p><img src="/images/custom/post/swift-apm-godeye/crash.jpg" alt="hello world" /></p>

<p>由图可见，我们不但可以看到崩溃的原因，还能看到崩溃的堆栈，极大的方便了我们debug。当然，这些信息只能在你崩溃后重新打开才能查看哦。</p>

<h3>Network</h3>

<p>第三个子模块就是Network，也就是网络请求和网络响应的监控，这个模块可以监控我们发出的网络请求各个字段以及对应的网络响应的各个字段。当然这些字段非常多，因此默认我们是折叠显示的：</p>

<p><img src="/images/custom/post/swift-apm-godeye/net_list.jpg" alt="hello world" /></p>

<p>折叠状态下，我们只能看到请求的URL。点击一下这个cell，我们就能展开这个cell，展开后我们可以看到各个有值的字段：</p>

<p><img src="/images/custom/post/swift-apm-godeye/net_detail.jpg" alt="hello world" /></p>

<h3>ANR</h3>

<p>第四个子模块就是ANR,Application Not Responsed，也就是应用不响应，平时我们叫它&mdash;卡顿。在我们日常使用中，经常会出现卡顿的现象，卡顿很难追踪，因为其偶然性以及原因复杂性都相对比较大。卡顿监控模块可以在发生卡顿时，记录所有的堆栈，方便追踪：</p>

<p><img src="/images/custom/post/swift-apm-godeye/anr_list.jpg" alt="hello world" /></p>

<p>当然上图只是折叠显示，折叠显示下只会展示卡顿时候的主线程堆栈，当然，一般卡顿的原因也都发生在主线程。当然，点击这个cell也能看到所有线程的堆栈：</p>

<p><img src="/images/custom/post/swift-apm-godeye/anr_detail.jpg" alt="hello world" /></p>

<h3>Leak</h3>

<p>第五个子模块是Leak模块，可以记录发生内存泄漏的对象，当出现内存泄漏的时候会将对象记录在这里。</p>

<h3>Terminal</h3>

<p>最后一个子模块就是终端模块，用户可以自定义指令，在App运行的任何地方任何时候都能输入你的指令，获得你想要的数据。当然，如果你忘了你配置过哪些指令，你也可以输入<code>help</code>指令，它会告诉你所有配置的指令:</p>

<p><img src="/images/custom/post/swift-apm-godeye/terminal.jpg" alt="hello world" /></p>

<h2>Monitor</h2>

<p>第二个tab页是monitor，就是各种硬件实时指标的监控器：</p>

<p><img src="/images/custom/post/swift-apm-godeye/monitor.jpg" alt="hello world" /></p>

<p>在这里我们可以实时监控系统的CPU，自身应用的CPU，应用的内存使用，系统的内存使用率，帧率FPS,应用的网络流量，系统的网络流量。后续版本迭代还会加入图表的功能，到时点击一个指标的监控数据，就可以看到历史心跳图，或者饼状图，应该会比较酷炫。</p>

<h2>File</h2>

<p>第三个tab是File,在这里我们可以查看我们App的沙盒文件，以及.app的内部包文件，还有就是整个手机的根目录文件：</p>

<p><img src="/images/custom/post/swift-apm-godeye/file_list.jpg" alt="hello world" /></p>

<p>选择一个目录后就会拉起我们的文件夹浏览器，可以查看文件夹下所有的文件以及文件夹：</p>

<p><img src="/images/custom/post/swift-apm-godeye/file_detail.jpg" alt="hello world" /></p>

<h2>Setting</h2>

<p>最后一个tab是Setting，当前版本可以配置我们的一些开关，后续版本迭代我们还会加入很多新的实时配置的东西，比如各种监控的阈值：</p>

<p><img src="/images/custom/post/swift-apm-godeye/setting.jpg" alt="hello world" /></p>

<h1>GodEye解决的痛点</h1>

<p>GodEye是一个APM，一个帮助解决开发和调试时候步骤多，成本大，不方便的工具集合，因此GodEye能解决的痛点比较多，也比较散。</p>

<p>上一节我们谈了GodEye的功能，这一节我们就来说说这些功能都解决了啥痛点。</p>

<h2>痛点</h2>

<h3>痛点1：查看日志需要连接Mac</h3>

<p>我们平时查看日志输出的时候，必须将我们的手机连接到Mac电脑，用Xcode来查看。而GodEye的日志监控功能，就可以实现直接在App内查看，方便省时，还可以对日志做类别区分。</p>

<h3>痛点2：Crash后需要Xcode查看堆栈</h3>

<p>日常开发中Crash难免，谁都不能保证自己开发的App一个Crash的问题都没有。若是在我们日常写代码Debug的阶段Crash的话还好，可以直接在Xcode的console里看到堆栈；麻烦的是在测试人员测试的时候遇到的问题，如果能够复现还好，我们可以按部就班将操作日志再次展现在我们的Xcode控制台上，而要是难以复现的bug，我们就需要将测试人员的手机拿过来，然后找到对应的<code>.dSYM</code>文件将一堆内存地址符号化成代码。</p>

<p>是不是非常复杂，GodEye的Crash监控模块就能解决这个问题，我们可以直接在手机上查看Crash堆栈，实时方便，珍爱生命。</p>

<h3>痛点3：测试网络需要Charles设代理</h3>

<p>Charles可以很方便的帮我们查看网络请求。如果读者对Charles不熟悉，可以看看巧神的&lt;iOS开发进阶>。当然，使用Charles也有不方便的时候，需要身边有一台电脑，需要设置代理。GodEye的网络监控模块就可以省去这个烦恼，直接在App内部查看网络请求和网络响应，非常方便。后续还会加入数据mock，以及实时修改数据等功能。</p>

<h3>痛点4：卡顿原因难以捕捉</h3>

<p>众所周知，在移动设备上开发应用，性能是每一个developer关心的问题。作为developer我们可以通过提高自身技术，提高代码质量来优化我们应用的性能。当然我们不一定能及时发现代码存在的性能问题，这时就需要有一个能够监控并及时告知我们应用中那些耗费性能导致应用卡顿的“Bug”。GodEye的卡顿监控模块就是为此而开发。</p>

<h3>痛点5：内存泄漏需要Instruments</h3>

<p>不容置疑，Instruments的功能非常全面也非常强大，Leak和Allcation模块也非常实用。但是Instruments我们并不是经常会去使用，而且Instruments也有很多不便，首先你得打开Allocations，然后，你得一个个场景去重复的操作，我们无法及时得知泄漏，得专门做一遍上述操作，十分繁琐。GodEye的内存泄漏模块可以实时反馈给你内存泄漏的对象，非常方便。</p>

<h3>痛点6：脱离Xcode就不能查看变量数据</h3>

<p>如果我们在脱离我们的Xcode的时候想像连着Xcode那样来po一个对象或者数据的话基本是不可能的，GodEye提供了一个输入控制台，使用者可以自定义好对应的指令，运行的时候随时输入即可得到对应的数据，当然这些指令没有Xcode那么强大，但是已经够用了。</p>

<h2>痛点7：无法得知硬件使用信息</h2>

<p>大家是否遇到过一些疑难杂症，比如应用出现一些很奇怪的现象，经过艰苦卓绝的Debug原来是因为内存爆了，好多ViewController收到了内存警告。要是我们能对我们的硬件做监控就好了，我们能实时的知道我们的iPhone系统的CPU使用率，内存的使用率，要是能知道我们自己的app使用了多少CPU，多少内存就更好了。对，GodEye的硬件监控模块就能告诉你这些硬件信息。</p>

<h3>痛点8：无法查看文件系统</h3>

<p>我们平时做一些I/O操作的时候其实对我们是很不直观的，我们可能加了个文件，也可能改了个文件，我们通过代码能知道是否成功，但是我们不能亲眼看到，他就放在那里。或者我们想看一下我们的图片是否放入了我们的bundle，都很不方便。GodEye的文件模块就能很好的解决这个问题，不但能看整个沙盒的内容，还能看<code>.app</code>内部的内容，当然，也能看整个手机的根目录。</p>

<h2>One More Thing</h2>

<p>以上8个痛点，无一不是步骤多，成本大，不方便。而GodEye提供的功能就是为了解决这8个痛点。后续也会将已有的功能做的更加晚上，探索发现一些新的功能。</p>

<p>能看到这里，说明你也将整本书看完了，再次感谢你的耐心，希望这本书能对你有所帮助。也希望你会喜欢GodEye。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2017-03-07T16:27:04+08:00" data-updated="true" itemprop="datePublished">Mar 7<span>th</span>, 2017</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2017/03/07/godeyezhi-ri-zhi-jian-kong/" itemprop="url">GodEye之日志监控</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>日志几乎是我们每一个iOS开发者每一天都要打交道的东西，比如运行时想看一下某个变量的值，那就<code>NSLog()</code>一下;当然，在Swift语言下我们还有另外一种选择,那就是<code>print()</code>方法。都是帮助我们方便调试与分析的工具。</p>


		
		<a href="/blog/2017/03/07/godeyezhi-ri-zhi-jian-kong/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-10-25T00:03:58+08:00" data-updated="true" itemprop="datePublished">Oct 25<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/10/25/chun-swift2-dot-0gong-cheng-cocoachina-plus-cong-0dao-1yu-dao-de-keng-he-jie-jue-fang-an/" itemprop="url">纯Swift2.0工程CocoaChina+从0到1遇到的坑和解决方案</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>好久没写技术文章了，感觉这个事情不应该被搁置，程序员应该努力去学一些除了写代码以外的东西。</p>

<p>前段时间博主从阿里巴巴跳槽加盟滴滴快的，乘着跳槽的时间差做了两件一直想做的事：
一件就是用Swift2.0写了一个CocoaChina的iOS app（名字叫CocoaChina+，文章的最后会介绍），另外一件就是带着女票去北京玩了一趟，见了见以前读硕时在实验室的几个哥们。整个app从无到有遇到了好多Swift的坑，只可惜没有一一记载下来，现在凭着记忆将还记得的坑以及好的东西记载下来与大家分享。</p>


		
		<a href="/blog/2015/10/25/chun-swift2-dot-0gong-cheng-cocoachina-plus-cong-0dao-1yu-dao-de-keng-he-jie-jue-fang-an/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-05-04T17:34:03+08:00" data-updated="true" itemprop="datePublished">May 4<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/05/04/xcode6cha-jian-kai-fa-ru-men/" itemprop="url">Xcode6插件开发入门</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Xcode提供了所有你创建一个App需要的功能。但是由于其不开源以及没有制作Xcode-Plugin相关的文档，在我们需要添加一些自己的想法和功能的时候变得缺乏灵活性。
但是我们可以通过一些非官方的手段来扩展我们自己的Xcode，并且分享给别人使用。</p>


		
		<a href="/blog/2015/05/04/xcode6cha-jian-kai-fa-ru-men/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-04-16T18:11:16+08:00" data-updated="true" itemprop="datePublished">Apr 16<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-dan-yuan-ce-shi-bian-ma-gui-fan/" itemprop="url">[iOS单元测试系列]单元测试编码规范</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>编写单元测试与编写工程代码略有不同。我们需要准备数据，mock对象，调用工程Api,验证结果。而且一般测试代码都会比工程代码要大。就像<a href="http://www.objc.io/issue-15/xctest.html">Real-World Testing with XCTest</a>一文中提到“目前为止，我们的编码库已经纵横 190 个文件和 18,000 行代码，达到了 544 kB。我们测试部分的代码现在差不多有1,200 kB，大概有被测试代码的两倍”。那么应该如何定义单元测试代码编写规范，使得代码更整洁，可读性更高呢？</p>


		
		<a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-dan-yuan-ce-shi-bian-ma-gui-fan/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-04-16T14:53:44+08:00" data-updated="true" itemprop="datePublished">Apr 16<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-singletonru-he-ce-shi/" itemprop="url">[iOS单元测试系列]Singleton如何测试</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Singletion设计模式在cocoa中被广泛使用。在我们平时写App代码时也经常会将一些工具类，管理类设计成Singletion。Signletion通过一个类方法返回一个唯一的实例，与我们平常通过实例化生成一个个实例的场景有所不同。如果我们要stub一个Singletion的类的实例方法，那么这个Signletion的类初始化方法（eg:sharedMange()）必须返回一个mock对象。因为只有mock对象才可以做stub操作。那么我们应该如何mock我们的Singletion呢，我们通过下面的例子一步步分析解决这个问题。</p>


		
		<a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-singletonru-he-ce-shi/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-04-16T14:51:27+08:00" data-updated="true" itemprop="datePublished">Apr 16<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-yi-ocmockchang-jian-shi-yong-fang-shi/" itemprop="url">[iOS单元测试系列]-译-OCMock常见使用方式</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><strong>NOTE:</strong> 本文翻译自OCMock官网中的一片教程外链<a href="http://hackazach.net/code/2014/03/03/effective-testing-with-ocmock/">OCMock Test Origami</a>。</p>

<p><strong>该文章使用的API是OCMock老版本的API，新版本也兼容老版本的API，译者在用到老版本的API处已经添加了对应的新版本（OCMock3）的API供读者参考。</strong></p>

<h3>爱好者</h3>

<p>这篇文章假设读者都能熟悉使用Xcode5的测试框架XCTest，或者BBD测试工具Kiwi或其他的iOS测试框架</p>

<h3>什么是mock？差不多就是纸老虎</h3>

<p>当我们写单元测试的时候，不可避免的要去尽可能少的实例化一些具体的组件来保持测试既短又快。而且保持单元的隔离。在现代的面向对象系统中，测试的组件很可能会有几个依赖的对象。我们用mock来替代实例化具体的依赖class。mock是在测试中的一个伪造的有预定义行为的具体对象的替身对象。被测试的组件不知道其中的差异！你的组件是在一个更大的系统中被设计的，你可以很有信心的用mock来测试你的组件。</p>


		
		<a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-yi-ocmockchang-jian-shi-yong-fang-shi/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-04-11T13:42:02+08:00" data-updated="true" itemprop="datePublished">Apr 11<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/04/11/iosdan-yuan-ce-shi-xi-lie-dan-yuan-ce-shi-kuang-jia-xuan-xing/" itemprop="url">[iOS单元测试系列]单元测试框架选型</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>这段时间在团队里一直在负责对单元测试的探索和落地，感觉有必要总结下自己这段时间的探索成果和大家分享。加之已经忙的很久没写博客了，感觉没有沉淀，这样不好。iOS单元测试系列会一直更新，按主题将我在单元测试探索和落地过程中的技术积累沉淀下来，也算是对自己这段时间的总结。部分观点是我个人观点，欢迎大家讨论。</p>

<p>一开始接到的不是单元测试的任务，而是与测试同学共建完成iOS上持续集成能跑测试用例的平台。然后我就吭哧吭哧的区研究Jenkins，后来发现不对，就算我把平台搭建好了没有测试用例也只是个空壳子，而应该合理分工，测试同学负责搭建平台，开发负责写测试用例。</p>


		
		<a href="/blog/2015/04/11/iosdan-yuan-ce-shi-xi-lie-dan-yuan-ce-shi-kuang-jia-xuan-xing/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-10-22T23:41:28+08:00" data-updated="true" itemprop="datePublished">Oct 22<span>nd</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/10/22/%3Cyi-%3Eios-8-today-extension-tutorial/" itemprop="url"><译>iOS 8 Today Extension Tutorial</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><strong>原文链接:</strong><a href="http://www.raywenderlich.com/83809/ios-8-today-extension-tutorial">iOS 8 Today Extension Tutorial</a></p>

<p><strong>Ray提醒: </strong> 这篇文章可以说是一个精简版，它是从<a href="http://www.raywenderlich.com/store/swift-tutorials-bundle">iOS8 by Tutirials</a>这本书中摘录的一个章节。<a href="http://www.raywenderlich.com/store/swift-tutorials-bundle">iOS8 by Tutirials</a>是我们<a href="http://www.raywenderlich.com/82230/introducing-ios-8-feast">iOS8 Feast</a>套餐中的一部分。通过这篇文章我们可以看到书中的内容是怎么样的。希望你喜欢！</p>

<p>iOS8介绍了一种新的概念 <code>App Extensions</code>:一种在操作系统上与其他应用共享应用程序功能的方式！</p>

<p>这些<code>Extensions</code>中有一种叫<code>Today Extensions</code>，又称<code>Widgets</code>。它可以让你在<code>Notification Center</code>中呈现信息。这是一种很好的方式向用户直接的提供他感兴趣的最新的信息。</p>

<p>在这个教程中，你会编写一个<code>Today Extension</code>用来渲染<a href="https://bitcoin.org/en/">bitcoin.org</a>中比特币基于美元的当前市场价格。</p>


		
		<a href="/blog/2014/10/22/%3Cyi-%3Eios-8-today-extension-tutorial/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-10-14T17:30:39+08:00" data-updated="true" itemprop="datePublished">Oct 14<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/10/14/yong-swiftshi-xian-%5B%3F%5D-ge-ju-you-lei-si-uitableviewzhong-cellzhong-yong-ji-zhi-de-heng-xiang-gun-dong-kong-jian/" itemprop="url">用Swift实现一个具有类似UITableView中Cell重用机制的横向滚动控件</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>这篇文章源于对一个可横向滚动并选择的类目控件的重构。最近在学<code>Swift</code>，所以把这个控件的核心逻辑（Cell重用）用<code>Swift</code>重写出来分享给大家。当然这不是Apple官方的Cell重用机制，因为Apple不开源.这篇文章应该会对正在学习<code>Swift</code>并且想了解Cell重用实现的同学有一定帮助。文章中涉及到的代码都放在了Github(<a href="https://github.com/zixun/ZXOptionBar-Swift">ZXOptionBar-Swift</a>),欢迎大家提issues，求血求虐求羞辱~</p>

<p>第一个版本中这个控件承载了数据、视图、动画等所有的逻辑，使得这个控件在后期变得很难维护。所以我必须重构这个控件，而想到<code>UITableView</code>也是一个可滚动可选择的控件，我为什么不把它做成一个类似<code>UITableView</code>一样的横向滚动的控件呢。通过<code>delegate</code>和<code>dataSource</code>把数据和动画从控件中分离出来，通过cell重用减小cell初始化的开支。</p>

<p>可是，Apple的<code>UIKit</code>不开源啊，怎么办呢？twitter为我们提供了很好的参考，那就是<a href="https://github.com/twitter/twui">TWUI</a>,这是twitter当年在MacOS上实现的类似<code>UIKit</code>的一个库，虽然已经2年没有更新了，但是里面还是有不少可以挖掘的好东西，比如Twitter版的<code>UITabelView</code>的Cell重用机制。</p>

<p><code>UITableView</code>是分很多<code>section</code>的，但是横向滚动的控件一般只会有一种Cell，不会像<code>UITableView</code>一样需要分很多不同种类的Cell，所以我们可以改造<a href="https://github.com/twitter/twui">TWUI</a>的Cell重用机制，使它更适合横向滚动的视图控件。</p>

<p><strong>Note:</strong>之前在团队内部做过一个这个控件的Cell重用的分享，用Keynote演示，不过是用Objective-C描述的，对于理解上会有帮助。Keynote文件也在Github上。</p>


		
		<a href="/blog/2014/10/14/yong-swiftshi-xian-%5B%3F%5D-ge-ju-you-lei-si-uitableviewzhong-cellzhong-yong-ji-zhi-de-heng-xiang-gun-dong-kong-jian/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2017

    陈奕龙


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




</body>
</html>

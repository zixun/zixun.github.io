
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>子循(SubCycle)</title>
	<meta name="author" content="陈奕龙">

	
	<meta name="description" content="Mar 10th, 2017 Swift APM大轮子-GodEye 0 前言 该文章摘自笔者撰写的一本iOS技术书籍iOS监控编程。 这是一本介绍iOS监控编程的书籍,内容涉及日志监控，监控崩溃，监控网络，监控卡顿，监控硬件，内存泄漏监控等方面。所有的功能都是通过自行编程实现， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="子循(SubCycle)" type="application/atom+xml">
	
	<link rel="canonical" href="http://zixun.github.io/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("chenyl.exe@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="http://about.me/shashankmehta">About</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

<section class="aboutme">
  <p>
    记录我的技术与生活
  </p>
</section>
</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:chenyl.exe@gmail.com" title="Email">Email</a>
		
		
		
		
		
			<a class="github" href="https://github.com/zixun" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2017-03-10T15:30:12+08:00" data-updated="true" itemprop="datePublished">Mar 10<span>th</span>, 2017</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2017/03/10/swift-apmda-lun-zi-godeye/" itemprop="url">Swift APM大轮子-GodEye</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>0 前言</h1>

<p>该文章摘自笔者撰写的一本iOS技术书籍<a href="https://www.qingdan.us/product/25">iOS监控编程</a>。</p>

<p>这是一本介绍iOS监控编程的书籍,内容涉及日志监控，监控崩溃，监控网络，监控卡顿，监控硬件，内存泄漏监控等方面。所有的功能都是通过自行编程实现，而不是通过使用第三方工具。每个章节记录了功能的实现细节，以及笔者一路探索过来的心路历程。当然，笔者后续依旧会寻求与探索新的监控方向，一旦有所得都会更新到本书的章节中。</p>

<p>这本书是笔者的开源工具<a href="https://github.com/zixun/GodEye">GodEye</a>的产出物，GodEye能全自动，零代码入侵，一行代码接入来监控应用的日志，卡顿，崩溃，网络，内存泄漏，CPU以及内存使用率，帧率等信息。</p>

<h1>什么是GodEye</h1>

<p>什么是<a href="https://github.com/zixun/GodEye">GodEye</a>？这个问题可以让GodEye自己告诉我们。</p>


		
		<a href="/blog/2017/03/10/swift-apmda-lun-zi-godeye/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2017-03-07T16:27:04+08:00" data-updated="true" itemprop="datePublished">Mar 7<span>th</span>, 2017</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2017/03/07/godeyezhi-ri-zhi-jian-kong/" itemprop="url">GodEye之日志监控</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>日志几乎是我们每一个iOS开发者每一天都要打交道的东西，比如运行时想看一下某个变量的值，那就<code>NSLog()</code>一下;当然，在Swift语言下我们还有另外一种选择,那就是<code>print()</code>方法。都是帮助我们方便调试与分析的工具。</p>


		
		<a href="/blog/2017/03/07/godeyezhi-ri-zhi-jian-kong/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-10-25T00:03:58+08:00" data-updated="true" itemprop="datePublished">Oct 25<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/10/25/chun-swift2-dot-0gong-cheng-cocoachina-plus-cong-0dao-1yu-dao-de-keng-he-jie-jue-fang-an/" itemprop="url">纯Swift2.0工程CocoaChina+从0到1遇到的坑和解决方案</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>好久没写技术文章了，感觉这个事情不应该被搁置，程序员应该努力去学一些除了写代码以外的东西。</p>

<p>前段时间博主从阿里巴巴跳槽加盟滴滴快的，乘着跳槽的时间差做了两件一直想做的事：
一件就是用Swift2.0写了一个CocoaChina的iOS app（名字叫CocoaChina+，文章的最后会介绍），另外一件就是带着女票去北京玩了一趟，见了见以前读硕时在实验室的几个哥们。整个app从无到有遇到了好多Swift的坑，只可惜没有一一记载下来，现在凭着记忆将还记得的坑以及好的东西记载下来与大家分享。</p>


		
		<a href="/blog/2015/10/25/chun-swift2-dot-0gong-cheng-cocoachina-plus-cong-0dao-1yu-dao-de-keng-he-jie-jue-fang-an/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-05-04T17:34:03+08:00" data-updated="true" itemprop="datePublished">May 4<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/05/04/xcode6cha-jian-kai-fa-ru-men/" itemprop="url">Xcode6插件开发入门</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Xcode提供了所有你创建一个App需要的功能。但是由于其不开源以及没有制作Xcode-Plugin相关的文档，在我们需要添加一些自己的想法和功能的时候变得缺乏灵活性。
但是我们可以通过一些非官方的手段来扩展我们自己的Xcode，并且分享给别人使用。</p>


		
		<a href="/blog/2015/05/04/xcode6cha-jian-kai-fa-ru-men/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-04-16T18:11:16+08:00" data-updated="true" itemprop="datePublished">Apr 16<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-dan-yuan-ce-shi-bian-ma-gui-fan/" itemprop="url">[iOS单元测试系列]单元测试编码规范</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>编写单元测试与编写工程代码略有不同。我们需要准备数据，mock对象，调用工程Api,验证结果。而且一般测试代码都会比工程代码要大。就像<a href="http://www.objc.io/issue-15/xctest.html">Real-World Testing with XCTest</a>一文中提到“目前为止，我们的编码库已经纵横 190 个文件和 18,000 行代码，达到了 544 kB。我们测试部分的代码现在差不多有1,200 kB，大概有被测试代码的两倍”。那么应该如何定义单元测试代码编写规范，使得代码更整洁，可读性更高呢？</p>


		
		<a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-dan-yuan-ce-shi-bian-ma-gui-fan/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-04-16T14:53:44+08:00" data-updated="true" itemprop="datePublished">Apr 16<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-singletonru-he-ce-shi/" itemprop="url">[iOS单元测试系列]Singleton如何测试</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Singletion设计模式在cocoa中被广泛使用。在我们平时写App代码时也经常会将一些工具类，管理类设计成Singletion。Signletion通过一个类方法返回一个唯一的实例，与我们平常通过实例化生成一个个实例的场景有所不同。如果我们要stub一个Singletion的类的实例方法，那么这个Signletion的类初始化方法（eg:sharedMange()）必须返回一个mock对象。因为只有mock对象才可以做stub操作。那么我们应该如何mock我们的Singletion呢，我们通过下面的例子一步步分析解决这个问题。</p>


		
		<a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-singletonru-he-ce-shi/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-04-16T14:51:27+08:00" data-updated="true" itemprop="datePublished">Apr 16<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-yi-ocmockchang-jian-shi-yong-fang-shi/" itemprop="url">[iOS单元测试系列]-译-OCMock常见使用方式</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><strong>NOTE:</strong> 本文翻译自OCMock官网中的一片教程外链<a href="http://hackazach.net/code/2014/03/03/effective-testing-with-ocmock/">OCMock Test Origami</a>。</p>

<p><strong>该文章使用的API是OCMock老版本的API，新版本也兼容老版本的API，译者在用到老版本的API处已经添加了对应的新版本（OCMock3）的API供读者参考。</strong></p>

<h3>爱好者</h3>

<p>这篇文章假设读者都能熟悉使用Xcode5的测试框架XCTest，或者BBD测试工具Kiwi或其他的iOS测试框架</p>

<h3>什么是mock？差不多就是纸老虎</h3>

<p>当我们写单元测试的时候，不可避免的要去尽可能少的实例化一些具体的组件来保持测试既短又快。而且保持单元的隔离。在现代的面向对象系统中，测试的组件很可能会有几个依赖的对象。我们用mock来替代实例化具体的依赖class。mock是在测试中的一个伪造的有预定义行为的具体对象的替身对象。被测试的组件不知道其中的差异！你的组件是在一个更大的系统中被设计的，你可以很有信心的用mock来测试你的组件。</p>


		
		<a href="/blog/2015/04/16/iosdan-yuan-ce-shi-xi-lie-yi-ocmockchang-jian-shi-yong-fang-shi/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-04-11T13:42:02+08:00" data-updated="true" itemprop="datePublished">Apr 11<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/04/11/iosdan-yuan-ce-shi-xi-lie-dan-yuan-ce-shi-kuang-jia-xuan-xing/" itemprop="url">[iOS单元测试系列]单元测试框架选型</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>这段时间在团队里一直在负责对单元测试的探索和落地，感觉有必要总结下自己这段时间的探索成果和大家分享。加之已经忙的很久没写博客了，感觉没有沉淀，这样不好。iOS单元测试系列会一直更新，按主题将我在单元测试探索和落地过程中的技术积累沉淀下来，也算是对自己这段时间的总结。部分观点是我个人观点，欢迎大家讨论。</p>

<p>一开始接到的不是单元测试的任务，而是与测试同学共建完成iOS上持续集成能跑测试用例的平台。然后我就吭哧吭哧的区研究Jenkins，后来发现不对，就算我把平台搭建好了没有测试用例也只是个空壳子，而应该合理分工，测试同学负责搭建平台，开发负责写测试用例。</p>


		
		<a href="/blog/2015/04/11/iosdan-yuan-ce-shi-xi-lie-dan-yuan-ce-shi-kuang-jia-xuan-xing/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-10-22T23:41:28+08:00" data-updated="true" itemprop="datePublished">Oct 22<span>nd</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/10/22/%3Cyi-%3Eios-8-today-extension-tutorial/" itemprop="url"><译>iOS 8 Today Extension Tutorial</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><strong>原文链接:</strong><a href="http://www.raywenderlich.com/83809/ios-8-today-extension-tutorial">iOS 8 Today Extension Tutorial</a></p>

<p><strong>Ray提醒: </strong> 这篇文章可以说是一个精简版，它是从<a href="http://www.raywenderlich.com/store/swift-tutorials-bundle">iOS8 by Tutirials</a>这本书中摘录的一个章节。<a href="http://www.raywenderlich.com/store/swift-tutorials-bundle">iOS8 by Tutirials</a>是我们<a href="http://www.raywenderlich.com/82230/introducing-ios-8-feast">iOS8 Feast</a>套餐中的一部分。通过这篇文章我们可以看到书中的内容是怎么样的。希望你喜欢！</p>

<p>iOS8介绍了一种新的概念 <code>App Extensions</code>:一种在操作系统上与其他应用共享应用程序功能的方式！</p>

<p>这些<code>Extensions</code>中有一种叫<code>Today Extensions</code>，又称<code>Widgets</code>。它可以让你在<code>Notification Center</code>中呈现信息。这是一种很好的方式向用户直接的提供他感兴趣的最新的信息。</p>

<p>在这个教程中，你会编写一个<code>Today Extension</code>用来渲染<a href="https://bitcoin.org/en/">bitcoin.org</a>中比特币基于美元的当前市场价格。</p>


		
		<a href="/blog/2014/10/22/%3Cyi-%3Eios-8-today-extension-tutorial/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-10-14T17:30:39+08:00" data-updated="true" itemprop="datePublished">Oct 14<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/10/14/yong-swiftshi-xian-%5B%3F%5D-ge-ju-you-lei-si-uitableviewzhong-cellzhong-yong-ji-zhi-de-heng-xiang-gun-dong-kong-jian/" itemprop="url">用Swift实现一个具有类似UITableView中Cell重用机制的横向滚动控件</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>这篇文章源于对一个可横向滚动并选择的类目控件的重构。最近在学<code>Swift</code>，所以把这个控件的核心逻辑（Cell重用）用<code>Swift</code>重写出来分享给大家。当然这不是Apple官方的Cell重用机制，因为Apple不开源.这篇文章应该会对正在学习<code>Swift</code>并且想了解Cell重用实现的同学有一定帮助。文章中涉及到的代码都放在了Github(<a href="https://github.com/zixun/ZXOptionBar-Swift">ZXOptionBar-Swift</a>),欢迎大家提issues，求血求虐求羞辱~</p>

<p>第一个版本中这个控件承载了数据、视图、动画等所有的逻辑，使得这个控件在后期变得很难维护。所以我必须重构这个控件，而想到<code>UITableView</code>也是一个可滚动可选择的控件，我为什么不把它做成一个类似<code>UITableView</code>一样的横向滚动的控件呢。通过<code>delegate</code>和<code>dataSource</code>把数据和动画从控件中分离出来，通过cell重用减小cell初始化的开支。</p>

<p>可是，Apple的<code>UIKit</code>不开源啊，怎么办呢？twitter为我们提供了很好的参考，那就是<a href="https://github.com/twitter/twui">TWUI</a>,这是twitter当年在MacOS上实现的类似<code>UIKit</code>的一个库，虽然已经2年没有更新了，但是里面还是有不少可以挖掘的好东西，比如Twitter版的<code>UITabelView</code>的Cell重用机制。</p>

<p><code>UITableView</code>是分很多<code>section</code>的，但是横向滚动的控件一般只会有一种Cell，不会像<code>UITableView</code>一样需要分很多不同种类的Cell，所以我们可以改造<a href="https://github.com/twitter/twui">TWUI</a>的Cell重用机制，使它更适合横向滚动的视图控件。</p>

<p><strong>Note:</strong>之前在团队内部做过一个这个控件的Cell重用的分享，用Keynote演示，不过是用Objective-C描述的，对于理解上会有帮助。Keynote文件也在Github上。</p>


		
		<a href="/blog/2014/10/14/yong-swiftshi-xian-%5B%3F%5D-ge-ju-you-lei-si-uitableviewzhong-cellzhong-yong-ji-zhi-de-heng-xiang-gun-dong-kong-jian/" class="more-link">阅读全文&rarr;</a>
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2017

    陈奕龙


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




</body>
</html>
